@page "/CommandCenter"
@inject IPlayerService _playerService
@inject IThrowService _throwService
@inject IPlayerThrowService _playerThrowService
@inject IMatchService _matchService
@inject IPosibleThrowService _posibleThrowService
@inject IMatchPlayerService _matchPlayerService
@inject ISignalRService _sigalRService
@inject NavigationManager navigation

@using Microsoft.AspNetCore.SignalR.Client

<div class="viewer"></div>
<Error ErrorMessage="@error"></Error>
<LoadingScreen IsBusy="@isBusyLoadingIndicator"></LoadingScreen>
@if (allPosibleThrow != null)
{

    <div>
        <div class="d-flex justify-content-between flex-wrap">
            @foreach (var item in allPosibleThrow)
            {
                <DartSegment DataModel="item"
                             OnSelected="ProcessThrow"></DartSegment>
            }
        </div>
        <div class="d-flex justify-content-center mt-3" id="bull-container">
            <div id="outer-bull" class="d-flex justify-content-center align-items-center" @onclick="e => ProcessThrow(posibleBullThrows[0])">
                <div id="inner-bull" @onclick="e => ProcessThrow(posibleBullThrows[1])" @onclick:stopPropagation></div>
            </div>

        </div>
    </div>
    if (!string.IsNullOrWhiteSpace(gameIsDoneMessage))
    {
        <div class="mt-2">
            <div class="error-message  alert-success w-50 m-auto">
                <p class="text-success p-2 text-center">@gameIsDoneMessage</p>
            </div>
        </div>
    }
    @if (currentMatch != null && string.IsNullOrWhiteSpace(error))
    {
        <div class="d-flex justify-content-center">
            <figure class="d-flex align-items-center justify-content-center">
                <img src="/images/darts.png" />
            </figure>
            <div class="w-100">
                <ScoreBoard AllPosibleThrow="allPosibleThrow"
                            PosibleBullThrows="posibleBullThrows"
                            CurrentMatch="currentMatch"></ScoreBoard>
            </div>
            <figure class="d-flex align-items-center justify-content-center">
                <img src="/images/darts.png" />
            </figure>
        </div>
    }

    <input type="button" class="btn btn-primary me-2 mb-3" @onclick="RedirectToAddPlayer" value="+Add Player" />
    <input type="button" class="btn btn-primary mb-3" @onclick="CreateCurrentMatch" value="New Match" />

}


@code {
    private DartsMatchModel currentMatch;
    private List<ScoresPerNumberModel> allPosibleThrow;
    private List<ScoreModel> posibleBullThrows;
    DartsPlayerModel playerWhoFinischedFirst;
    private string error = "";
    private bool isBusyLoadingIndicator;
    private string gameIsDoneMessage = "";


    private void RedirectToAddPlayer()
    {
        navigation.NavigateTo("/AddPlayer");
    }

    protected async override Task OnInitializedAsync()
    {
        isBusyLoadingIndicator = true;
        allPosibleThrow = await _posibleThrowService.CreateAllThrows();
        posibleBullThrows = await _posibleThrowService.CreateAllBullThrows();
        if (allPosibleThrow == null || posibleBullThrows == null) error = "Something went wrong please restart!";
        isBusyLoadingIndicator = false;

    }

    private async Task CreateCurrentMatch()
    {

        var result = await _playerService.GetAllPlayersAsync();
        int maxPlayerCount;
        Random random = new Random();
        currentMatch = new DartsMatchModel();

        List<DartsPlayerModel> valibleCandidated = new();

        if (result.IsSucces)
        {

            var playerThatAreNotInMatch = result.Items.Where(p => !p.Matches.Any(m => m.Match.IsActiveGame == true)).ToList();
            maxPlayerCount = playerThatAreNotInMatch.Count();
            ItemResultModel<Player> availeblePlayersResult = new();
            DartsPlayerModel playerOne = new();
            if (maxPlayerCount >= 2)
            {
                var players = ConvertToDartsPlayerModel(playerThatAreNotInMatch);//Find suitable playerOne

                while (players.Count >= 2 && !availeblePlayersResult.IsSucces)
                {
                    playerOne = players.ElementAt(random.Next(0, maxPlayerCount));
                    playerOne.IsActiveTurn = true;

                    availeblePlayersResult = await _playerService.GetApponentByPlayerId(playerOne.Id);
                    if (!availeblePlayersResult.IsSucces) players.Remove(playerOne);
                    maxPlayerCount = players.Count();
                }
                //end
                if (availeblePlayersResult.IsSucces)
                {
                    valibleCandidated = ConvertToDartsPlayerModel(availeblePlayersResult.Items.ToList());//Find suitable playerTwo

                    maxPlayerCount = valibleCandidated.Count();
                    var playerTwo = valibleCandidated[random.Next(0, maxPlayerCount)];//end
                    var createMatchResult = await _matchService.CreateAsync(playerOne.Id, playerTwo.Id);
                    if (createMatchResult.IsSucces)
                    {
                        currentMatch = createMatchResult.Items.Select(cm => new DartsMatchModel
                        {
                            PlayerOne = playerOne,
                            PlayerTwo = playerTwo,
                            Id = cm.Id,
                            IsActiveMatch = cm.IsActiveGame,
                        }).FirstOrDefault();

                        await _matchPlayerService.CreateAsync(currentMatch.Id, playerOne.Id);
                        await _matchPlayerService.CreateAsync(currentMatch.Id, playerTwo.Id);

                        error = String.Empty;
                        gameIsDoneMessage = string.Empty;
                        await _sigalRService.SendNewMatch(currentMatch);

                    }
                    else error = createMatchResult.ErrorMessage;



                }
                else error = availeblePlayersResult.ErrorMessage;
            }
            else error = "No available players!";
        };
    }

    private List<DartsPlayerModel> ConvertToDartsPlayerModel(List<Player> players)
    {
        return players.Select(p => new DartsPlayerModel
        {
            Id = p.Id,
            FirstName = p.Firstname,
            LastName = p.Lastname,
            Throws = new List<ThrowModel>()
        }).ToList();
    }

    private async Task ProcessThrow(ScoreModel score)
    {
        if (currentMatch != null)
        {

            var currentPlayer = currentMatch.PlayerOne.IsActiveTurn == true ? currentMatch.PlayerOne : currentMatch.PlayerTwo;

            var createResult = await _playerThrowService.CreateAsync(currentMatch.Id, currentPlayer.Id, score.Id);
            if (createResult.IsSucces)
            {
                var getResult = await _playerThrowService.GetByUserAndMatchIdAsync(currentMatch.Id, currentPlayer.Id);
                if (getResult.IsSucces)
                {
                    currentPlayer.Throws = getResult.Items.Select(t => new ThrowModel
                    {
                        BaseNumber = (int)t.Score.OriginalScore,
                        Throw = (int)t.Score.Score,
                        TimeStamp = t.TimeStamp
                    }).ToList();
                }
                await AddScore(currentPlayer, score);
            }
        }
        else error = "Please create a match!";

    }

    private bool CheckPlayerEligibiletyForAddingScore(DartsPlayerModel player, ScoreModel number)
    {

        DartsPlayerModel opponent = currentMatch.PlayerOne == player ? currentMatch.PlayerTwo : currentMatch.PlayerOne;
        bool shouldGetScore = false;

        foreach (var property in player.FinischedNumbers.GetType().GetProperties())
        {
            if (property.Name == number.Name || number.Name.Contains(property.Name)) //uitzondering voor bull
            {
                foreach (var opponentProperty in opponent.FinischedNumbers.GetType().GetProperties())
                {
                    if (property.Name == opponentProperty.Name &&
                        (bool)property.GetValue(player.FinischedNumbers) == true && (bool)opponentProperty.GetValue(opponent.FinischedNumbers) == false)
                    {
                        shouldGetScore = true;
                        break;
                    }
                }
                break;
            }
        }

        return shouldGetScore;
    }

    private async Task AddScore(DartsPlayerModel player, ScoreModel score)
    {
        if (player.Throws.Any())
        {
            var allThrowOfNumber = player.Throws.Where(t => t.BaseNumber == score.BaseScore).ToList();
            int total = allThrowOfNumber.Sum(a => a.Throw);
            int amountOfHits = total / score.BaseScore;

            if (amountOfHits >= 3)
            {
                foreach (var property in player.FinischedNumbers.GetType().GetProperties())
                {

                    if (property.Name == score.Name || score.Name.Contains(property.Name))//uitzondering voor bull
                    {
                        bool isFinischedBefore = (bool)property.GetValue(player.FinischedNumbers);
                        property.SetValue(player.FinischedNumbers, true);
                        bool shouldGetScore = CheckPlayerEligibiletyForAddingScore(player, score);
                        if (shouldGetScore)
                        {
                            if (isFinischedBefore) player.Score += score.Score;
                            else player.Score += total - score.BaseScore * 3;
                            var resultPlayerMatchFound = await _matchPlayerService.GetByMatchAndPlayerId(currentMatch.Id, player.Id);
                            if (resultPlayerMatchFound.IsSucces)
                            {
                                var foundMatchPlayer = resultPlayerMatchFound.Items.FirstOrDefault();
                                foundMatchPlayer.Score = player.Score;
                                await _matchPlayerService.UpdateAsync(foundMatchPlayer.Id, currentMatch.Id, player.Id, player.Score);
                            }
                        }

                        break;
                    }
                }
            }
            var gameIsDone = CheckGameIsDone(player);
            if (gameIsDone) {
                await _sigalRService.SendNewThrow(currentMatch,score, player,true);
                await CloseGame(gameIsDone);
            }
            else await _sigalRService.SendNewThrow(currentMatch,score, player);
        }
    }   

    private async Task CloseGame(bool gameIsDone)
    {
        var winner = currentMatch.PlayerOne.Score > currentMatch.PlayerTwo.Score ? currentMatch.PlayerOne : currentMatch.PlayerTwo;
        var loser = currentMatch.PlayerOne.Score < currentMatch.PlayerTwo.Score ? currentMatch.PlayerOne : currentMatch.PlayerTwo;
        bool isSame = false;
        if (currentMatch.PlayerOne.Score == currentMatch.PlayerTwo.Score)
        {
            winner = playerWhoFinischedFirst;
            loser = currentMatch.PlayerOne == winner ? currentMatch.PlayerTwo : currentMatch.PlayerOne;
            isSame = true;
        }
        if (gameIsDone)
        {
            gameIsDoneMessage = $"The winner is {winner.FirstName}-{winner.LastName} with a score of {winner.Score} vs {loser.Score}!!\n";
            if (isSame) gameIsDoneMessage += $"{winner.FirstName}-{winner.LastName} has finisched the game first!!";

            var result = await _matchService.UpdateAsync(currentMatch.Id, false, currentMatch.PlayerOne.Score, currentMatch.PlayerTwo.Score);
            await _sigalRService.SendNewWinner(winner);
            if (result.IsSucces) currentMatch = null;
            else error = result.ErrorMessage;
        }
    }

    private bool CheckGameIsDone(DartsPlayerModel player)
    {

        DartsPlayerModel opponent = currentMatch.PlayerOne == player ? currentMatch.PlayerTwo : currentMatch.PlayerOne;
        bool playerIsFinisched = CheckPlayerIsDone(player);
        bool opponentIsFinisched = CheckPlayerIsDone(opponent);
        if(playerIsFinisched != opponentIsFinisched)
        {
            playerWhoFinischedFirst = playerIsFinisched ? player : opponent;
        }
        if (playerIsFinisched && opponentIsFinisched) return true;
        return false;
    }

    private bool CheckPlayerIsDone(DartsPlayerModel player)
    {
        bool IsDone = true;
        foreach (var property in player.FinischedNumbers.GetType().GetProperties())
        {
            IsDone = (bool)property.GetValue(player.FinischedNumbers);
            if (!IsDone)
            {
                break;
            }
        }

        return IsDone;
    }



}








